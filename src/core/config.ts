import path from 'path';
import fs from 'fs';
import findUp from 'find-up';
import { TaskEither, tryCatch } from 'fp-ts/lib/TaskEither';

import { emphasize, jsonParse, json5Stringify } from './utils';
import { GroupConfig } from './groups/add';
import { Dictionary } from './types';
import { VersionGuardError } from './errors';

const JSON_HEADER =
  '// This file was auto-generated by `versionguard`. Do not manually modify, use the `versionguard` CLI instead.';
export const CONFIG_FILENAME = '.versionguardrc.json';

export type VersionGuardConfig = Dictionary<GroupConfig>;

export function getConfigPathForBase(basePath: string): string {
  return path.resolve(basePath, CONFIG_FILENAME);
}

export async function findConfig(): Promise<string | undefined> {
  return findUp(CONFIG_FILENAME);
}

export async function readConfig(
  configPath: string,
): Promise<VersionGuardConfig> {
  try {
    const fileContent = await fs.promises.readFile(configPath);
    const config = jsonParse(fileContent.toString());
    return config as VersionGuardConfig;
  } catch (e) {
    throw new VersionGuardError(
      emphasize`Config file at path "${configPath}" is corrupted. Cannot proceed.`,
    );
  }
}

export function writeConfig(
  path: string,
): (
  data: VersionGuardConfig,
) => TaskEither<VersionGuardError, VersionGuardConfig> {
  return data =>
    tryCatch(
      async () => {
        await fs.promises.writeFile(
          path,
          `${JSON_HEADER}\n${json5Stringify(data, err => err).value}`,
        );
        return data;
      },
      reason => VersionGuardError.from(String(reason)),
    );
}
