import stdMocks from 'std-mocks';
import fs from 'fs';
import path from 'path';
import stripAnsi from 'strip-ansi';
import mockStdin from 'mock-stdin';

import { cleanFixtureDir } from '../../../test/utils/cleanFixtureDir';
import { removeAutogeneratedConfigFile } from '../../../test/utils/removeAutogeneratedConfigFile';
import { trim } from '../../../test/utils/trimTemplateTag';
import { executeCli } from '..';
import { waitForStdout } from '../../../test/utils/waitForStdout';
import { ArgumentsWithConfig } from '../types';

const FIXTURE_DIR = path.resolve(__dirname, '../../../test/fixtures/');

function executeCliWithConfigPath(
  configPath: string,
  ...args: string[]
): Promise<ArgumentsWithConfig> {
  return executeCli(args.concat(`--config-path=${configPath}`), false);
}

function executeCliWithCopiedConfigFixture(
  fixtureDir: string,
): (...args: string[]) => Promise<{ configPath: string }> {
  return async function copyConfigFixtureAndExecute(...args: string[]) {
    const fixturePath = path.resolve(
      FIXTURE_DIR,
      fixtureDir,
      'config_fixture.json',
    );
    const fixtureCopyPath = path.join(
      path.dirname(fixturePath),
      `copied_config_fixture_${Math.random().toString(36)}.json`,
    );
    await fs.promises.copyFile(fixturePath, fixtureCopyPath);
    await executeCliWithConfigPath(fixtureCopyPath, ...args);
    return {
      configPath: fixtureCopyPath,
    };
  };
}

function cleanCliOutput(output: string[]): string {
  return output
    .reduce((a, b) => a.concat(stripAnsi(b).split('\n')), [] as string[])
    .filter(str => str && !str.includes('console.log'))
    .map(str => str.trim())
    .join('\n');
}

function getCleanedMockStdout(): string {
  return cleanCliOutput(stdMocks.flush().stdout);
}

function formatGroupListOutput(groups: string[]): string {
  return trim`
    ℹ Groups found:
    ${groups.map(group => `${group}`).join('\n')}
  `;
}

async function assertGroupListContainsGroupsInOrder(
  configPath: string,
  ...groups: string[]
): Promise<void> {
  await executeCliWithConfigPath(configPath, 'groups:list');
  expect(getCleanedMockStdout()).toBe(formatGroupListOutput(groups));
}

function guard(): void {
  expect(true).toBe(false);
}

describe('versionguard', () => {
  beforeAll(() => cleanFixtureDir(FIXTURE_DIR));
  beforeEach(removeAutogeneratedConfigFile);
  beforeEach(() => stdMocks.use());
  afterEach(() => {
    const { stderr, stdout } = stdMocks.flush();
    stdMocks.restore();
    //output captured data left in stdoutand stderr
    const cleanedStderr = cleanCliOutput(stderr);
    if (cleanedStderr) {
      console.log(cleanedStderr);
    }
    const cleanedStdout = cleanCliOutput(stdout);
    if (cleanedStdout) {
      console.log(cleanedStdout);
    }
  });

  describe('global', () => {
    it('should create a config file if none exists when calling a command', async () => {
      await executeCli(['groups:list']);
      expect(getCleanedMockStdout()).toContain(
        `No config file found, creating config at path: ${process.cwd()}/.versionguardrc.json`,
      );
    });
  });

  describe('groups', () => {
    it('`groups:add` should allow adding', async () => {
      const output = await executeCliWithCopiedConfigFixture(
        'groups/two_groups',
      )('groups:add', 'test');
      expect(getCleanedMockStdout()).toContain('✔ Group test added!');
      await assertGroupListContainsGroupsInOrder(
        output.configPath,
        'a',
        'b',
        'test',
      );
    });

    it('`groups:rename` should allow renaming', async () => {
      const output = await executeCliWithCopiedConfigFixture(
        'groups/two_groups',
      )('groups:rename', 'a', 'test');
      expect(getCleanedMockStdout()).toContain('✔ Group a renamed to test!');
      await assertGroupListContainsGroupsInOrder(
        output.configPath,
        'b',
        'test',
      );
    });

    it('`groups:remove` should allow removing', async () => {
      const output = await executeCliWithCopiedConfigFixture(
        'groups/two_groups',
      )('groups:remove', 'a');
      expect(getCleanedMockStdout()).toContain('✔ Group a removed!');
      await assertGroupListContainsGroupsInOrder(output.configPath, 'b');
    });

    it('`groups:list` should list all groups', async () => {
      await executeCliWithCopiedConfigFixture('groups/two_groups')(
        'groups:list',
      );
      expect(getCleanedMockStdout()).toBe(formatGroupListOutput(['a', 'b']));
    });

    it('`groups:info` should show info for a single group', async () => {
      await executeCliWithCopiedConfigFixture('groups/one_complete_group')(
        'groups:info',
        'a',
      );

      expect(getCleanedMockStdout()).toContain(`a

Applications: application_a, application_b

Dependency sets
┌───────┬────────────────────────┬────────────┐
│       │Dependencies            │Grace period│
├───────┼────────────────────────┼────────────┤
│public │dep_a@1.0.0, dep_b@2.0.0│Infinity    │
│private│dep_c@3.0.0             │Infinity    │
└───────┴────────────────────────┴────────────┘`);
    });
  });

  describe('applications', () => {
    it('`applications:add` should allow adding an application to a group', async () => {
      const { configPath } = await executeCliWithCopiedConfigFixture(
        'applications/empty_group',
      )('applications:add', 'a', 'application_a');
      expect(getCleanedMockStdout()).toContain(
        '✔ Application in path application_a added to group a',
      );
      await executeCliWithConfigPath(configPath, 'groups:info', 'a');
      expect(getCleanedMockStdout()).toContain('Applications: application_a');
    });

    it('`applications:add` should allow adding multiple applications to a group', async () => {
      const { configPath } = await executeCliWithCopiedConfigFixture(
        'applications/empty_group',
      )('applications:add', 'a', 'application_a', 'application_b');
      expect(getCleanedMockStdout()).toContain(
        '✔ Applications in paths application_a, application_b added to group a',
      );
      await executeCliWithConfigPath(configPath, 'groups:info', 'a');
      expect(getCleanedMockStdout()).toContain(
        'Applications: application_a, application_b',
      );
    });

    it('`applications:remove` should allow removing an application from a group', async () => {
      const { configPath } = await executeCliWithCopiedConfigFixture(
        'applications/one_application',
      )('applications:remove', 'a', 'application_a');
      expect(getCleanedMockStdout()).toContain(
        '✔ Application in path application_a removed from group a',
      );
      await executeCliWithConfigPath(configPath, 'groups:info', 'a');
      expect(getCleanedMockStdout()).not.toContain('application_a');
    });

    it('`applications:remove` should allow removing multiple applications from a group', async () => {
      const { configPath } = await executeCliWithCopiedConfigFixture(
        'applications/two_applications',
      )('applications:remove', 'a', 'application_a', 'application_b');
      expect(getCleanedMockStdout()).toContain(
        '✔ Applications in paths application_a, application_b removed from group a',
      );
      await executeCliWithConfigPath(configPath, 'groups:info', 'a');
      const output = getCleanedMockStdout();
      expect(output).not.toContain('application_a');
      expect(output).not.toContain('application_b');
    });
  });

  describe('dependencies', () => {
    it('`dependencies:create-set` should allow adding a dependency set to a group', async () => {
      await executeCliWithCopiedConfigFixture('dependencies/one_group')(
        'dependencies:create-set',
        'a',
        'set_a',
      );
      expect(getCleanedMockStdout()).toContain(
        '✔ Dependency set set_a created within group a',
      );
    });

    it('`dependencies:delete-set` should allow removing a dependency set from a group', async () => {
      await executeCliWithCopiedConfigFixture(
        'dependencies/one_dependency_set',
      )('dependencies:delete-set', 'a', 'set_a');
      expect(getCleanedMockStdout()).toContain(
        '✔ Dependency set set_a deleted from group a',
      );
    });

    it('`dependencies:add` should allow adding a dependency to a dependency set within a group', async () => {
      await executeCliWithCopiedConfigFixture(
        'dependencies/one_dependency_set',
      )('dependencies:add', 'a', 'set_a', 'dep_a@1.0.0');
      expect(getCleanedMockStdout()).toContain(
        '✔ Dependency dep_a@1.0.0 successfully added to set set_a within group a',
      );
    });

    it('`dependencies:add` should prevent adding a dependency with an invalid semver range ', () => {
      return Promise.all(
        ['', '@', '@.1.1'].map(async range => {
          try {
            await executeCliWithCopiedConfigFixture(
              'dependencies/one_dependency_set',
            )('dependencies:add', 'a', 'set_a', `dep_a${range}`);
            // should never get here
            guard();
          } catch (e) {
            expect(getCleanedMockStdout()).toBe(
              `✖ ${range.replace(
                '@',
                '',
              )} for dep_a is not a valid semver range`,
            );
          }
        }),
      );
    });

    it('should allow allow moving a dependency between dependency sets within a group', async () => {
      // need to hook into the real stdout for a bit
      stdMocks.restore();
      const stdin = mockStdin.stdin();
      const cliExecution = executeCliWithCopiedConfigFixture(
        'dependencies/existing_dependency_in_set',
      )('dependencies:add', 'a', 'private', 'dep_a@1.0.0');

      await waitForStdout('Would you like to migrate');
      stdMocks.use();
      stdin.send('y\n').restore();

      const { configPath } = await cliExecution;
      expect(getCleanedMockStdout()).toContain(
        '✔ Dependency dep_a@1.0.0 successfully migrated to set private within group a',
      );

      await executeCliWithConfigPath(configPath, 'groups:info', 'a');
      expect(getCleanedMockStdout()).toContain(trim`
        │public │            │Infinity    │
        │private│dep_a@1.0.0 │Infinity    │
      `);
    });

    it("should allow updating a dependency's version within the same set", async () => {
      const { configPath } = await executeCliWithCopiedConfigFixture(
        'dependencies/existing_dependency_in_set',
      )('dependencies:add', 'a', 'public', 'dep_a@2.0.0');
      expect(getCleanedMockStdout()).toContain(
        '✔ Dependency dep_a@2.0.0 successfully updated within set public',
      );
      await executeCliWithConfigPath(configPath, 'groups:info', 'a');
      expect(getCleanedMockStdout()).toContain(trim`
        │public │dep_a@2.0.0 │Infinity    │
        │private│            │Infinity    │
      `);
    });

    it('should allow removing a dependency from a dependency set within a group', async () => {
      const { configPath } = await executeCliWithCopiedConfigFixture(
        'dependencies/existing_dependency_in_set',
      )('dependencies:remove', 'a', 'public', 'dep_a');
      expect(getCleanedMockStdout()).toContain(
        '✔ Dependency dep_a successfully removed from set public within group a',
      );
      await executeCliWithConfigPath(configPath, 'groups:info', 'a');
      expect(getCleanedMockStdout()).toContain(trim`
        │public │            │Infinity    │
        │private│            │Infinity    │
      `);
    });
  });

  describe('check', () => {
    describe('no arguments', () => {
      describe('only valid entries', () => {
        it('should pass', async () => {
          await executeCliWithCopiedConfigFixture('check/simple-config-valid')(
            'check',
          );
          expect(getCleanedMockStdout()).toBe('✔ Check passed!');
        });

        it('should pass, verbose', async () => {
          await executeCliWithCopiedConfigFixture('check/simple-config-valid')(
            'check',
            '--verbose',
          );
          expect(getCleanedMockStdout()).toBe(trim`
            ℹ
            ┌─────────────┬──────────┬─────────┬────────┬─────┐
            │Application  │Dependency│Installed│Required│Valid│
            ├─────────────┼──────────┼─────────┼────────┼─────┤
            │application_a│dep_a     │^1.0.0   │1.x     │✔    │
            │             │dep_b     │1.2.3    │1.x     │✔    │
            │             │dep_c     │~1.5.0   │1.x     │✔    │
            │application_b│dep_a     │^1.0.0   │1.x     │✔    │
            │             │dep_b     │1.2.3    │1.x     │✔    │
            │             │dep_c     │~1.5.0   │1.x     │✔    │
            └─────────────┴──────────┴─────────┴────────┴─────┘
            ✔ Check passed!
          `);
        });
      });

      describe('only invalid entries', () => {
        it('should fail', async () => {
          try {
            await executeCliWithCopiedConfigFixture(
              'check/simple-config-invalid',
            )('check');
            guard();
          } catch (e) {
            expect(getCleanedMockStdout()).toBe(
              '✖ Group all-invalid-a did not meet dependency version requirements',
            );
          }
        });

        it('should fail, verbose', async () => {
          try {
            await executeCliWithCopiedConfigFixture(
              'check/simple-config-invalid',
            )('check', '--verbose');
            guard();
          } catch (e) {
            expect(getCleanedMockStdout()).toBe(trim`
              ℹ
              ┌─────────────┬──────────┬─────────┬────────┬─────┐
              │Application  │Dependency│Installed│Required│Valid│
              ├─────────────┼──────────┼─────────┼────────┼─────┤
              │application_a│dep_a     │^1.0.0   │3.x     │✖    │
              │             │dep_b     │1.2.3    │3.x     │✖    │
              │             │dep_c     │~1.5.0   │3.x     │✖    │
              │application_b│dep_a     │^1.0.0   │3.x     │✖    │
              │             │dep_b     │1.2.3    │3.x     │✖    │
              │             │dep_c     │~1.5.0   │3.x     │✖    │
              └─────────────┴──────────┴─────────┴────────┴─────┘
              ✖ Group all-invalid-a did not meet dependency version requirements
            `);
          }
        });
      });
    });
  });

  describe('--group', () => {
    describe('single group with only valid entries', () => {
      const args = ['check', '--group', 'all-valid-a'];
      it('should pass', async () => {
        await executeCliWithCopiedConfigFixture('check/mixed-config')(...args);
        expect(getCleanedMockStdout()).toBe('✔ Check passed!');
      });
      it('should pass, verbose', async () => {
        await executeCliWithCopiedConfigFixture('check/mixed-config')(
          ...args,
          '--verbose',
        );
        expect(getCleanedMockStdout()).toBe(trim`
            ℹ
            ┌─────────────┬──────────┬─────────┬────────┬─────┐
            │Application  │Dependency│Installed│Required│Valid│
            ├─────────────┼──────────┼─────────┼────────┼─────┤
            │application_a│dep_a     │^1.0.0   │1.x     │✔    │
            │             │dep_b     │1.2.3    │1.x     │✔    │
            │             │dep_c     │~1.5.0   │1.x     │✔    │
            │application_b│dep_a     │^1.0.0   │1.x     │✔    │
            │             │dep_b     │1.2.3    │1.x     │✔    │
            │             │dep_c     │~1.5.0   │1.x     │✔    │            
            └─────────────┴──────────┴─────────┴────────┴─────┘
            ✔ Check passed!
          `);
      });
    });

    describe('single group with invalid entries', () => {
      const args = ['check', '--group', 'all-invalid-a'];
      it('should fail', async () => {
        try {
          await executeCliWithCopiedConfigFixture('check/mixed-config')(
            ...args,
          );
          guard();
        } catch (e) {
          expect(getCleanedMockStdout()).toBe(
            '✖ Group all-invalid-a did not meet dependency version requirements',
          );
        }
      });

      it('should fail, verbose', async () => {
        try {
          await executeCliWithCopiedConfigFixture('check/mixed-config')(
            ...args,
            '--verbose',
          );
          guard();
        } catch (e) {
          expect(getCleanedMockStdout()).toBe(trim`
            ℹ
            ┌─────────────┬──────────┬─────────┬────────┬─────┐
            │Application  │Dependency│Installed│Required│Valid│
            ├─────────────┼──────────┼─────────┼────────┼─────┤
            │application_a│dep_a     │^1.0.0   │3.x     │✖    │
            │             │dep_b     │1.2.3    │3.x     │✖    │
            │             │dep_c     │~1.5.0   │3.x     │✖    │
            │application_b│dep_a     │^1.0.0   │3.x     │✖    │
            │             │dep_b     │1.2.3    │3.x     │✖    │
            │             │dep_c     │~1.5.0   │3.x     │✖    │            
            └─────────────┴──────────┴─────────┴────────┴─────┘
            ✖ Group all-invalid-a did not meet dependency version requirements
          `);
        }
      });
    });

    describe('multiple groups with valid entries', () => {
      it('should pass', async () => {
        await executeCliWithCopiedConfigFixture('check/mixed-config')(
          'check',
          '--group',
          'all-valid-a',
          'all-valid-b',
        );
        expect(getCleanedMockStdout()).toBe('✔ Check passed!');
      });

      it('should pass, verbose', async () => {
        await executeCliWithCopiedConfigFixture('check/mixed-config')(
          'check',
          '--group',
          'all-valid-a',
          'all-valid-b',
          '--verbose',
        );
        expect(getCleanedMockStdout()).toBe(trim`
            ℹ
            ┌─────────────┬──────────┬─────────┬────────┬─────┐
            │Application  │Dependency│Installed│Required│Valid│
            ├─────────────┼──────────┼─────────┼────────┼─────┤
            │application_a│dep_a     │^1.0.0   │1.x     │✔    │
            │             │dep_b     │1.2.3    │1.x     │✔    │
            │             │dep_c     │~1.5.0   │1.x     │✔    │
            │application_b│dep_a     │^1.0.0   │1.x     │✔    │
            │             │dep_b     │1.2.3    │1.x     │✔    │
            │             │dep_c     │~1.5.0   │1.x     │✔    │
            └─────────────┴──────────┴─────────┴────────┴─────┘
            ┌─────────────┬──────────┬─────────┬────────┬─────┐
            │Application  │Dependency│Installed│Required│Valid│
            ├─────────────┼──────────┼─────────┼────────┼─────┤
            │application_c│dep_a     │^1.0.0   │1.x     │✔    │
            │             │dep_b     │1.2.3    │1.x     │✔    │
            │             │dep_c     │~1.5.0   │1.x     │✔    │
            │application_d│dep_a     │^1.0.0   │1.x     │✔    │
            │             │dep_b     │1.2.3    │1.x     │✔    │
            │             │dep_c     │~1.5.0   │1.x     │✔    │
            └─────────────┴──────────┴─────────┴────────┴─────┘
            ✔ Check passed!
          `);
      });
    });

    describe('multiple groups with invalid entries', () => {
      const args = ['check', '--group', 'all-invalid-a', 'all-invalid-b'];
      it('should fail', async () => {
        try {
          await executeCliWithCopiedConfigFixture('check/mixed-config')(
            ...args,
          );
          guard();
        } catch (e) {
          expect(getCleanedMockStdout()).toBe(
            '✖ Groups all-invalid-a, all-invalid-b did not meet dependency version requirements',
          );
        }
      });
      it('should fail, verbose', async () => {
        try {
          await executeCliWithCopiedConfigFixture('check/mixed-config')(
            ...args,
            '--verbose',
          );
          guard();
        } catch (e) {
          expect(getCleanedMockStdout()).toBe(trim`
            ℹ
            ┌─────────────┬──────────┬─────────┬────────┬─────┐
            │Application  │Dependency│Installed│Required│Valid│
            ├─────────────┼──────────┼─────────┼────────┼─────┤
            │application_a│dep_a     │^1.0.0   │3.x     │✖    │
            │             │dep_b     │1.2.3    │3.x     │✖    │
            │             │dep_c     │~1.5.0   │3.x     │✖    │
            │application_b│dep_a     │^1.0.0   │3.x     │✖    │
            │             │dep_b     │1.2.3    │3.x     │✖    │
            │             │dep_c     │~1.5.0   │3.x     │✖    │
            └─────────────┴──────────┴─────────┴────────┴─────┘
            ┌─────────────┬──────────┬─────────┬────────┬─────┐
            │Application  │Dependency│Installed│Required│Valid│
            ├─────────────┼──────────┼─────────┼────────┼─────┤
            │application_c│dep_a     │^1.0.0   │3.x     │✖    │
            │             │dep_b     │1.2.3    │3.x     │✖    │
            │             │dep_c     │~1.5.0   │3.x     │✖    │
            │application_d│dep_a     │^1.0.0   │3.x     │✖    │
            │             │dep_b     │1.2.3    │3.x     │✖    │
            │             │dep_c     │~1.5.0   │3.x     │✖    │
            └─────────────┴──────────┴─────────┴────────┴─────┘
            ✖ Groups all-invalid-a, all-invalid-b did not meet dependency version requirements
          `);
        }
      });
    });
  });

  describe('--app', () => {
    describe('single application with valid entries in single group', () => {
      const args = ['check', '--app', 'application_e'];
      it('should pass', async () => {
        await executeCliWithCopiedConfigFixture('check/mixed-config')(...args);
        expect(getCleanedMockStdout()).toBe('✔ Check passed!');
      });
      it('should pass, verbose', async () => {
        await executeCliWithCopiedConfigFixture('check/mixed-config')(
          ...args,
          '--verbose',
        );
        expect(getCleanedMockStdout()).toBe(trim`
            ℹ
            ┌─────────────┬──────────┬─────────┬────────┬─────┐
            │Application  │Dependency│Installed│Required│Valid│
            ├─────────────┼──────────┼─────────┼────────┼─────┤
            │application_e│dep_a     │^1.0.0   │1.x     │✔    │
            │             │dep_b     │1.2.3    │1.x     │✔    │
            │             │dep_c     │~1.5.0   │1.x     │✔    │
            └─────────────┴──────────┴─────────┴────────┴─────┘
            ✔ Check passed!
          `);
      });
    });

    describe('multiple applications with valid entries in different groups', () => {
      const args = ['check', '--app', 'application_e', 'application_f'];
      it('should pass', async () => {
        await executeCliWithCopiedConfigFixture('check/mixed-config')(...args);
        expect(getCleanedMockStdout()).toBe('✔ Check passed!');
      });
      it('should pass, verbose', async () => {
        await executeCliWithCopiedConfigFixture('check/mixed-config')(
          ...args,
          '--verbose',
        );
        expect(getCleanedMockStdout()).toBe(trim`
            ℹ
            ┌─────────────┬──────────┬─────────┬────────┬─────┐
            │Application  │Dependency│Installed│Required│Valid│
            ├─────────────┼──────────┼─────────┼────────┼─────┤
            │application_e│dep_a     │^1.0.0   │1.x     │✔    │
            │             │dep_b     │1.2.3    │1.x     │✔    │
            │             │dep_c     │~1.5.0   │1.x     │✔    │
            └─────────────┴──────────┴─────────┴────────┴─────┘
            ┌─────────────┬──────────┬─────────┬────────┬─────┐
            │Application  │Dependency│Installed│Required│Valid│
            ├─────────────┼──────────┼─────────┼────────┼─────┤
            │application_f│dep_a     │^1.0.0   │1.x     │✔    │
            │             │dep_b     │1.2.3    │1.x     │✔    │
            │             │dep_c     │~1.5.0   │1.x     │✔    │
            └─────────────┴──────────┴─────────┴────────┴─────┘            
            ✔ Check passed!
          `);
      });
    });

    describe('single application with valid and invalid entries in multiple groups', () => {
      const args = ['check', '--app', 'application_a'];
      it('should fail', async () => {
        try {
          await executeCliWithCopiedConfigFixture('check/mixed-config')(
            ...args,
          );
          guard();
        } catch (e) {
          expect(getCleanedMockStdout()).toBe(
            '✖ Group all-invalid-a did not meet dependency version requirements',
          );
        }
      });
      it('should fail, verbose', async () => {
        try {
          await executeCliWithCopiedConfigFixture('check/mixed-config')(
            ...args,
            '--verbose',
          );
          guard();
        } catch (e) {
          expect(getCleanedMockStdout()).toBe(trim`
            ℹ
            ┌─────────────┬──────────┬─────────┬────────┬─────┐
            │Application  │Dependency│Installed│Required│Valid│
            ├─────────────┼──────────┼─────────┼────────┼─────┤
            │application_a│dep_a     │^1.0.0   │1.x     │✔    │
            │             │dep_b     │1.2.3    │1.x     │✔    │
            │             │dep_c     │~1.5.0   │1.x     │✔    │
            └─────────────┴──────────┴─────────┴────────┴─────┘
            ┌─────────────┬──────────┬─────────┬────────┬─────┐
            │Application  │Dependency│Installed│Required│Valid│
            ├─────────────┼──────────┼─────────┼────────┼─────┤
            │application_a│dep_a     │^1.0.0   │3.x     │✖    │
            │             │dep_b     │1.2.3    │3.x     │✖    │
            │             │dep_c     │~1.5.0   │3.x     │✖    │
            └─────────────┴──────────┴─────────┴────────┴─────┘
            ✖ Group all-invalid-a did not meet dependency version requirements
          `);
        }
      });
    });
  });

  describe('--set', () => {
    describe('single set with valid entries existing in multiple groups', () => {
      it('should pass', async () => {
        await executeCliWithCopiedConfigFixture('check/mixed-config')(
          'check',
          '--set',
          'public-allvalid',
        );
        expect(getCleanedMockStdout()).toBe('✔ Check passed!');
      });
      it('should pass, verbose', async () => {
        await executeCliWithCopiedConfigFixture('check/mixed-config')(
          'check',
          '--set',
          'public-allvalid',
          '--verbose',
        );
        expect(getCleanedMockStdout()).toBe(trim`
            ℹ
            ┌─────────────┬──────────┬─────────┬────────┬─────┐
            │Application  │Dependency│Installed│Required│Valid│
            ├─────────────┼──────────┼─────────┼────────┼─────┤
            │application_e│dep_a     │^1.0.0   │1.x     │✔    │
            │             │dep_b     │1.2.3    │1.x     │✔    │
            └─────────────┴──────────┴─────────┴────────┴─────┘
            ┌─────────────┬──────────┬─────────┬────────┬─────┐
            │Application  │Dependency│Installed│Required│Valid│
            ├─────────────┼──────────┼─────────┼────────┼─────┤
            │application_f│dep_a     │^1.0.0   │1.x     │✔    │
            │             │dep_b     │1.2.3    │1.x     │✔    │
            └─────────────┴──────────┴─────────┴────────┴─────┘            
            ✔ Check passed!
          `);
      });
    });

    describe('single set with valid and invalid entries existing in multiple groups', () => {
      const args = ['check', '--set', 'public'];
      it('should fail', async () => {
        try {
          await executeCliWithCopiedConfigFixture('check/mixed-config')(
            ...args,
          );
          guard();
        } catch (e) {
          expect(getCleanedMockStdout()).toBe(
            '✖ Groups all-invalid-a, all-invalid-b did not meet dependency version requirements',
          );
        }
      });
      it('should fail, verbose', async () => {
        try {
          await executeCliWithCopiedConfigFixture('check/mixed-config')(
            ...args,
            '--verbose',
          );
          guard();
        } catch (e) {
          expect(getCleanedMockStdout()).toBe(trim`
            ℹ
            ┌─────────────┬──────────┬─────────┬────────┬─────┐
            │Application  │Dependency│Installed│Required│Valid│
            ├─────────────┼──────────┼─────────┼────────┼─────┤
            │application_a│dep_a     │^1.0.0   │1.x     │✔    │
            │             │dep_b     │1.2.3    │1.x     │✔    │
            │application_b│dep_a     │^1.0.0   │1.x     │✔    │
            │             │dep_b     │1.2.3    │1.x     │✔    │
            └─────────────┴──────────┴─────────┴────────┴─────┘
            ┌─────────────┬──────────┬─────────┬────────┬─────┐
            │Application  │Dependency│Installed│Required│Valid│
            ├─────────────┼──────────┼─────────┼────────┼─────┤
            │application_c│dep_a     │^1.0.0   │1.x     │✔    │
            │             │dep_b     │1.2.3    │1.x     │✔    │
            │application_d│dep_a     │^1.0.0   │1.x     │✔    │
            │             │dep_b     │1.2.3    │1.x     │✔    │
            └─────────────┴──────────┴─────────┴────────┴─────┘
            ┌─────────────┬──────────┬─────────┬────────┬─────┐
            │Application  │Dependency│Installed│Required│Valid│
            ├─────────────┼──────────┼─────────┼────────┼─────┤
            │application_a│dep_a     │^1.0.0   │3.x     │✖    │
            │             │dep_b     │1.2.3    │3.x     │✖    │
            │application_b│dep_a     │^1.0.0   │3.x     │✖    │
            │             │dep_b     │1.2.3    │3.x     │✖    │
            └─────────────┴──────────┴─────────┴────────┴─────┘
            ┌─────────────┬──────────┬─────────┬────────┬─────┐
            │Application  │Dependency│Installed│Required│Valid│
            ├─────────────┼──────────┼─────────┼────────┼─────┤
            │application_c│dep_a     │^1.0.0   │3.x     │✖    │
            │             │dep_b     │1.2.3    │3.x     │✖    │
            │application_d│dep_a     │^1.0.0   │3.x     │✖    │
            │             │dep_b     │1.2.3    │3.x     │✖    │
            └─────────────┴──────────┴─────────┴────────┴─────┘
            ✖ Groups all-invalid-a, all-invalid-b did not meet dependency version requirements
          `);
        }
      });
    });

    describe('multiple sets with valid entries in multiple groups', () => {
      const args = ['check', '--set', 'public-allvalid', 'private-allvalid'];
      it('should pass', async () => {
        await executeCliWithCopiedConfigFixture('check/mixed-config')(...args);
        expect(getCleanedMockStdout()).toBe('✔ Check passed!');
      });
      it('should pass, verbose', async () => {
        await executeCliWithCopiedConfigFixture('check/mixed-config')(
          ...args,
          '--verbose',
        );
        expect(getCleanedMockStdout()).toBe(trim`
            ℹ
            ┌─────────────┬──────────┬─────────┬────────┬─────┐
            │Application  │Dependency│Installed│Required│Valid│
            ├─────────────┼──────────┼─────────┼────────┼─────┤
            │application_e│dep_a     │^1.0.0   │1.x     │✔    │
            │             │dep_b     │1.2.3    │1.x     │✔    │
            │             │dep_c     │~1.5.0   │1.x     │✔    │
            └─────────────┴──────────┴─────────┴────────┴─────┘
            ┌─────────────┬──────────┬─────────┬────────┬─────┐
            │Application  │Dependency│Installed│Required│Valid│
            ├─────────────┼──────────┼─────────┼────────┼─────┤
            │application_f│dep_a     │^1.0.0   │1.x     │✔    │
            │             │dep_b     │1.2.3    │1.x     │✔    │
            │             │dep_c     │~1.5.0   │1.x     │✔    │
            └─────────────┴──────────┴─────────┴────────┴─────┘            
            ✔ Check passed!
          `);
      });
    });

    describe('multiple sets with valid and invalid entries existing in multiple groups', () => {
      const args = ['check', '--set', 'public', 'private'];
      it('should fail', async () => {
        try {
          await executeCliWithCopiedConfigFixture('check/mixed-config')(
            ...args,
          );
          guard();
        } catch (e) {
          expect(getCleanedMockStdout()).toBe(
            '✖ Groups all-invalid-a, all-invalid-b did not meet dependency version requirements',
          );
        }
      });
      it('should fail, verbose', async () => {
        try {
          await executeCliWithCopiedConfigFixture('check/mixed-config')(
            ...args,
            '--verbose',
          );
          guard();
        } catch (e) {
          expect(getCleanedMockStdout()).toBe(trim`
            ℹ
            ┌─────────────┬──────────┬─────────┬────────┬─────┐
            │Application  │Dependency│Installed│Required│Valid│
            ├─────────────┼──────────┼─────────┼────────┼─────┤
            │application_a│dep_a     │^1.0.0   │1.x     │✔    │
            │             │dep_b     │1.2.3    │1.x     │✔    │
            │             │dep_c     │~1.5.0   │1.x     │✔    │            
            │application_b│dep_a     │^1.0.0   │1.x     │✔    │
            │             │dep_b     │1.2.3    │1.x     │✔    │
            │             │dep_c     │~1.5.0   │1.x     │✔    │            
            └─────────────┴──────────┴─────────┴────────┴─────┘
            ┌─────────────┬──────────┬─────────┬────────┬─────┐
            │Application  │Dependency│Installed│Required│Valid│
            ├─────────────┼──────────┼─────────┼────────┼─────┤
            │application_c│dep_a     │^1.0.0   │1.x     │✔    │
            │             │dep_b     │1.2.3    │1.x     │✔    │
            │             │dep_c     │~1.5.0   │1.x     │✔    │            
            │application_d│dep_a     │^1.0.0   │1.x     │✔    │
            │             │dep_b     │1.2.3    │1.x     │✔    │
            │             │dep_c     │~1.5.0   │1.x     │✔    │            
            └─────────────┴──────────┴─────────┴────────┴─────┘
            ┌─────────────┬──────────┬─────────┬────────┬─────┐
            │Application  │Dependency│Installed│Required│Valid│
            ├─────────────┼──────────┼─────────┼────────┼─────┤
            │application_a│dep_a     │^1.0.0   │3.x     │✖    │
            │             │dep_b     │1.2.3    │3.x     │✖    │
            │             │dep_c     │~1.5.0   │3.x     │✖    │            
            │application_b│dep_a     │^1.0.0   │3.x     │✖    │
            │             │dep_b     │1.2.3    │3.x     │✖    │
            │             │dep_c     │~1.5.0   │3.x     │✖    │            
            └─────────────┴──────────┴─────────┴────────┴─────┘
            ┌─────────────┬──────────┬─────────┬────────┬─────┐
            │Application  │Dependency│Installed│Required│Valid│
            ├─────────────┼──────────┼─────────┼────────┼─────┤
            │application_c│dep_a     │^1.0.0   │3.x     │✖    │
            │             │dep_b     │1.2.3    │3.x     │✖    │
            │             │dep_c     │~1.5.0   │3.x     │✖    │            
            │application_d│dep_a     │^1.0.0   │3.x     │✖    │
            │             │dep_b     │1.2.3    │3.x     │✖    │
            │             │dep_c     │~1.5.0   │3.x     │✖    │            
            └─────────────┴──────────┴─────────┴────────┴─────┘
            ✖ Groups all-invalid-a, all-invalid-b did not meet dependency version requirements
          `);
        }
      });
    });

    describe('--group, --app and --set combinations', () => {
      const argsA = [
        'check',
        '--group',
        'all-valid-a',
        '--app',
        'application_a',
        '--set',
        'public',
      ];
      describe(argsA.slice(1).join(' '), () => {
        it('should pass', async () => {
          await executeCliWithCopiedConfigFixture('check/mixed-config')(
            ...argsA,
          );
          expect(getCleanedMockStdout()).toBe('✔ Check passed!');
        });

        it('should pass, verbose', async () => {
          await executeCliWithCopiedConfigFixture('check/mixed-config')(
            ...argsA,
            '--verbose',
          );
          expect(getCleanedMockStdout()).toBe(trim`
            ℹ
            ┌─────────────┬──────────┬─────────┬────────┬─────┐
            │Application  │Dependency│Installed│Required│Valid│
            ├─────────────┼──────────┼─────────┼────────┼─────┤
            │application_a│dep_a     │^1.0.0   │1.x     │✔    │
            │             │dep_b     │1.2.3    │1.x     │✔    │
            └─────────────┴──────────┴─────────┴────────┴─────┘
            ✔ Check passed!
          `);
        });
      });

      const argsB = [
        'check',
        '--group',
        'all-valid-a',
        '--app',
        'application_a',
        '--set',
        'public',
        'private',
      ];
      describe(argsB.slice(1).join(' '), () => {
        it('should pass', async () => {
          await executeCliWithCopiedConfigFixture('check/mixed-config')(
            ...argsB,
          );
          expect(getCleanedMockStdout()).toBe('✔ Check passed!');
        });

        it('should pass, verbose', async () => {
          await executeCliWithCopiedConfigFixture('check/mixed-config')(
            ...argsB,
            '--verbose',
          );
          expect(getCleanedMockStdout()).toBe(trim`
            ℹ
            ┌─────────────┬──────────┬─────────┬────────┬─────┐
            │Application  │Dependency│Installed│Required│Valid│
            ├─────────────┼──────────┼─────────┼────────┼─────┤
            │application_a│dep_a     │^1.0.0   │1.x     │✔    │
            │             │dep_b     │1.2.3    │1.x     │✔    │
            │             │dep_c     │~1.5.0   │1.x     │✔    │
            └─────────────┴──────────┴─────────┴────────┴─────┘
            ✔ Check passed!
          `);
        });
      });

      const argsC = [
        'check',
        '--group',
        'all-valid-a',
        '--app',
        'application_a',
        'application_b',
        '--set',
        'public',
        'private',
      ];
      describe(argsC.slice(1).join(' '), () => {
        it('should pass', async () => {
          await executeCliWithCopiedConfigFixture('check/mixed-config')(
            ...argsC,
          );
          expect(getCleanedMockStdout()).toBe('✔ Check passed!');
        });

        it('should pass, verbose', async () => {
          await executeCliWithCopiedConfigFixture('check/mixed-config')(
            ...argsC,
            '--verbose',
          );
          expect(getCleanedMockStdout()).toBe(trim`
            ℹ
            ┌─────────────┬──────────┬─────────┬────────┬─────┐
            │Application  │Dependency│Installed│Required│Valid│
            ├─────────────┼──────────┼─────────┼────────┼─────┤
            │application_a│dep_a     │^1.0.0   │1.x     │✔    │
            │             │dep_b     │1.2.3    │1.x     │✔    │
            │             │dep_c     │~1.5.0   │1.x     │✔    │
            │application_b│dep_a     │^1.0.0   │1.x     │✔    │
            │             │dep_b     │1.2.3    │1.x     │✔    │
            │             │dep_c     │~1.5.0   │1.x     │✔    │            
            └─────────────┴──────────┴─────────┴────────┴─────┘
            ✔ Check passed!
          `);
        });
      });

      const argsD = [
        'check',
        '--group',
        'all-valid-a',
        'all-invalid-a',
        '--app',
        'application_a',
        'application_b',
        '--set',
        'public',
        'private',
      ];
      describe(argsD.slice(1).join(' '), () => {
        it('should fail', async () => {
          try {
            await executeCliWithCopiedConfigFixture('check/mixed-config')(
              ...argsD,
            );
            guard();
          } catch (e) {
            expect(getCleanedMockStdout()).toBe(
              '✖ Group all-invalid-a did not meet dependency version requirements',
            );
          }
        });

        it('should fail, verbose', async () => {
          try {
            await executeCliWithCopiedConfigFixture('check/mixed-config')(
              ...argsD,
              '--verbose',
            );
            guard();
          } catch (e) {
            expect(getCleanedMockStdout()).toContain(trim`
              ┌─────────────┬──────────┬─────────┬────────┬─────┐
              │Application  │Dependency│Installed│Required│Valid│
              ├─────────────┼──────────┼─────────┼────────┼─────┤
              │application_a│dep_a     │^1.0.0   │1.x     │✔    │
              │             │dep_b     │1.2.3    │1.x     │✔    │
              │             │dep_c     │~1.5.0   │1.x     │✔    │
              │application_b│dep_a     │^1.0.0   │1.x     │✔    │
              │             │dep_b     │1.2.3    │1.x     │✔    │
              │             │dep_c     │~1.5.0   │1.x     │✔    │
              └─────────────┴──────────┴─────────┴────────┴─────┘
              ┌─────────────┬──────────┬─────────┬────────┬─────┐
              │Application  │Dependency│Installed│Required│Valid│
              ├─────────────┼──────────┼─────────┼────────┼─────┤              
              │application_a│dep_a     │^1.0.0   │3.x     │✖    │
              │             │dep_b     │1.2.3    │3.x     │✖    │
              │             │dep_c     │~1.5.0   │3.x     │✖    │
              │application_b│dep_a     │^1.0.0   │3.x     │✖    │
              │             │dep_b     │1.2.3    │3.x     │✖    │
              │             │dep_c     │~1.5.0   │3.x     │✖    │
              └─────────────┴──────────┴─────────┴────────┴─────┘
              ✖ Group all-invalid-a did not meet dependency version requirements
            `);
          }
        });
      });
    });

    it.todo(
      'should pass and warn if some dependency versions in a group are invalid but inside the grace period',
    );

    it.todo(
      'should fail if some dependency versions in a group are invalid and outside the grace period',
    );
  });
});
