import stdMocks from 'std-mocks';
import fs from 'fs';
import path from 'path';
import stripAnsi from 'strip-ansi';
import mockStdin from 'mock-stdin';

import { cleanFixtureDir } from '../../../test/utils/cleanFixtureDir';
import { removeAutogeneratedConfigFile } from '../../../test/utils/removeAutogeneratedConfigFile';
import { trim } from '../../../test/utils/trimTemplateTag';
import { executeCli } from '..';
import { waitForStdout } from '../../../test/utils/waitForStdout';
import { ArgumentsWithConfig } from '../types';

const FIXTURE_DIR = path.resolve(__dirname, '../../../test/fixtures/');

function executeCliWithConfigPath(
  configPath: string,
  ...args: string[]
): Promise<ArgumentsWithConfig> {
  return executeCli(args.concat(`--config-path=${configPath}`), false);
}

function executeCliWithCopiedConfigFixture(
  fixtureDir: string,
): (...args: string[]) => Promise<{ configPath: string }> {
  return async function copyConfigFixtureAndExecute(...args: string[]) {
    const fixturePath = path.resolve(
      FIXTURE_DIR,
      fixtureDir,
      'config_fixture.json',
    );
    const fixtureCopyPath = path.join(
      path.dirname(fixturePath),
      `copied_config_fixture_${Math.random().toString(36)}.json`,
    );
    await fs.promises.copyFile(fixturePath, fixtureCopyPath);
    await executeCliWithConfigPath(fixtureCopyPath, ...args);
    return {
      configPath: fixtureCopyPath,
    };
  };
}

function cleanCliOutput(output: string[]): string {
  return output
    .reduce((a, b) => a.concat(stripAnsi(b).split('\n')), [] as string[])
    .filter(str => str && !str.includes('console.log'))
    .map(str => str.trim())
    .join('\n');
}

function getCleanedMockStdout(): string {
  return cleanCliOutput(stdMocks.flush().stdout);
}

function formatGroupListOutput(groups: string[]): string {
  return trim`
    ℹ Groups found:
    ${groups.map(group => `ℹ ${group}`).join('\n')}
  `;
}

async function assertGroupListContainsGroupsInOrder(
  configPath: string,
  ...groups: string[]
): Promise<void> {
  await executeCliWithConfigPath(configPath, 'groups:list');
  expect(getCleanedMockStdout()).toBe(formatGroupListOutput(groups));
}

describe('versionguard', () => {
  beforeAll(() => cleanFixtureDir(FIXTURE_DIR));
  beforeEach(removeAutogeneratedConfigFile);
  beforeEach(() => stdMocks.use());
  afterEach(() => {
    const { stderr, stdout } = stdMocks.flush();
    stdMocks.restore();
    //output captured data left in stdoutand stderr
    const cleanedStderr = cleanCliOutput(stderr);
    if (cleanedStderr) {
      console.log(cleanedStderr);
    }
    const cleanedStdout = cleanCliOutput(stdout);
    if (cleanedStdout) {
      console.log(cleanedStdout);
    }
  });

  describe('global', () => {
    it('should create a config file if none exists when calling a command', async () => {
      await executeCli(['groups:list']);
      expect(getCleanedMockStdout()).toContain(
        `No config file found, creating config at path: ${process.cwd()}/.versionguardrc.json`,
      );
    });
  });

  describe('groups', () => {
    it('`groups:add` should allow adding', async () => {
      const output = await executeCliWithCopiedConfigFixture(
        'groups/two_groups',
      )('groups:add', 'test');
      expect(getCleanedMockStdout()).toContain('✔ Group test added!');
      await assertGroupListContainsGroupsInOrder(
        output.configPath,
        'a',
        'b',
        'test',
      );
    });

    it('`groups:rename` should allow renaming', async () => {
      const output = await executeCliWithCopiedConfigFixture(
        'groups/two_groups',
      )('groups:rename', 'a', 'test');
      expect(getCleanedMockStdout()).toContain('✔ Group a renamed to test!');
      await assertGroupListContainsGroupsInOrder(
        output.configPath,
        'b',
        'test',
      );
    });

    it('`groups:remove` should allow removing', async () => {
      const output = await executeCliWithCopiedConfigFixture(
        'groups/two_groups',
      )('groups:remove', 'a');
      expect(getCleanedMockStdout()).toContain('✔ Group a removed!');
      await assertGroupListContainsGroupsInOrder(output.configPath, 'b');
    });

    it('`groups:list` should list all groups', async () => {
      await executeCliWithCopiedConfigFixture('groups/two_groups')(
        'groups:list',
      );
      expect(getCleanedMockStdout()).toBe(formatGroupListOutput(['a', 'b']));
    });

    it('`groups:info` should show info for a single group', async () => {
      await executeCliWithCopiedConfigFixture('groups/one_complete_group')(
        'groups:info',
        'a',
      );

      expect(getCleanedMockStdout()).toBe(`ℹ a

Applications: application_a, application_b

Dependency sets
┌───────┬────────────────────────┬────────────┐
│       │Dependencies            │Grace period│
├───────┼────────────────────────┼────────────┤
│public │dep_a@1.0.0, dep_b@2.0.0│Infinity    │
│private│dep_c@3.0.0             │Infinity    │
└───────┴────────────────────────┴────────────┘`);
    });
  });

  describe('applications', () => {
    it('`applications:add` should allow adding an application to a group', async () => {
      const { configPath } = await executeCliWithCopiedConfigFixture(
        'applications/empty_group',
      )('applications:add', 'a', 'application_a');
      expect(getCleanedMockStdout()).toContain(
        '✔ Application in path application_a added to group a',
      );
      await executeCliWithConfigPath(configPath, 'groups:info', 'a');
      expect(getCleanedMockStdout()).toContain('Applications: application_a');
    });

    it('`applications:add` should allow adding multiple applications to a group', async () => {
      const { configPath } = await executeCliWithCopiedConfigFixture(
        'applications/empty_group',
      )('applications:add', 'a', 'application_a', 'application_b');
      expect(getCleanedMockStdout()).toContain(
        '✔ Applications in paths application_a, application_b added to group a',
      );
      await executeCliWithConfigPath(configPath, 'groups:info', 'a');
      expect(getCleanedMockStdout()).toContain(
        'Applications: application_a, application_b',
      );
    });

    it('`applications:remove` should allow removing an application from a group', async () => {
      const { configPath } = await executeCliWithCopiedConfigFixture(
        'applications/one_application',
      )('applications:remove', 'a', 'application_a');
      expect(getCleanedMockStdout()).toContain(
        '✔ Application in path application_a removed from group a',
      );
      await executeCliWithConfigPath(configPath, 'groups:info', 'a');
      expect(getCleanedMockStdout()).not.toContain('application_a');
    });

    it('`applications:remove` should allow removing multiple applications from a group', async () => {
      const { configPath } = await executeCliWithCopiedConfigFixture(
        'applications/two_applications',
      )('applications:remove', 'a', 'application_a', 'application_b');
      expect(getCleanedMockStdout()).toContain(
        '✔ Applications in paths application_a, application_b removed from group a',
      );
      await executeCliWithConfigPath(configPath, 'groups:info', 'a');
      const output = getCleanedMockStdout();
      expect(output).not.toContain('application_a');
      expect(output).not.toContain('application_b');
    });
  });

  describe('dependencies', () => {
    it('`dependencies:create-set` should allow adding a dependency set to a group', async () => {
      await executeCliWithCopiedConfigFixture('dependencies/one_group')(
        'dependencies:create-set',
        'a',
        'set_a',
      );
      expect(getCleanedMockStdout()).toContain(
        '✔ Dependency set set_a created within group a',
      );
    });

    it('`dependencies:delete-set` should allow removing a dependency set from a group', async () => {
      await executeCliWithCopiedConfigFixture(
        'dependencies/one_dependency_set',
      )('dependencies:delete-set', 'a', 'set_a');
      expect(getCleanedMockStdout()).toContain(
        '✔ Dependency set set_a deleted from group a',
      );
    });

    it('`dependencies:add` should allow adding a dependency to a dependency set within a group', async () => {
      await executeCliWithCopiedConfigFixture(
        'dependencies/one_dependency_set',
      )('dependencies:add', 'a', 'set_a', 'dep_a@1.0.0');
      expect(getCleanedMockStdout()).toContain(
        '✔ Dependency dep_a@1.0.0 successfully added to set set_a within group a',
      );
    });

    it('`dependencies:add` should prevent adding a dependency with an invalid semver range ', () => {
      return Promise.all(
        ['', '@', '@.1.1'].map(async range => {
          try {
            await executeCliWithCopiedConfigFixture(
              'dependencies/one_dependency_set',
            )('dependencies:add', 'a', 'set_a', `dep_a${range}`);
            // should never get here
            expect(true).toBe(false);
          } catch (e) {
            expect(getCleanedMockStdout()).toBe(
              `✖ ${range.replace(
                '@',
                '',
              )} for dep_a is not a valid semver range`,
            );
          }
        }),
      );
    });

    it('should allow allow moving a dependency between dependency sets within a group', async () => {
      // need to hook into the real stdout for a bit
      stdMocks.restore();
      const stdin = mockStdin.stdin();
      const cliExecution = executeCliWithCopiedConfigFixture(
        'dependencies/existing_dependency_in_set',
      )('dependencies:add', 'a', 'private', 'dep_a@1.0.0');

      await waitForStdout('Would you like to migrate');
      stdMocks.use();
      stdin.send('y\n').restore();

      const { configPath } = await cliExecution;
      expect(getCleanedMockStdout()).toContain(
        '✔ Dependency dep_a@1.0.0 successfully migrated to set private within group a',
      );

      await executeCliWithConfigPath(configPath, 'groups:info', 'a');
      expect(getCleanedMockStdout()).toContain(trim`
        │public │            │Infinity    │
        │private│dep_a@1.0.0 │Infinity    │
      `);
    });

    it("should allow updating a dependency's version within the same set", async () => {
      const { configPath } = await executeCliWithCopiedConfigFixture(
        'dependencies/existing_dependency_in_set',
      )('dependencies:add', 'a', 'public', 'dep_a@2.0.0');
      expect(getCleanedMockStdout()).toContain(
        '✔ Dependency dep_a@2.0.0 successfully updated within set public',
      );
      await executeCliWithConfigPath(configPath, 'groups:info', 'a');
      expect(getCleanedMockStdout()).toContain(trim`
        │public │dep_a@2.0.0 │Infinity    │
        │private│            │Infinity    │
      `);
    });

    it('should allow removing a dependency from a dependency set within a group', async () => {
      const { configPath } = await executeCliWithCopiedConfigFixture(
        'dependencies/existing_dependency_in_set',
      )('dependencies:remove', 'a', 'public', 'dep_a');
      expect(getCleanedMockStdout()).toContain(
        '✔ Dependency dep_a successfully removed from set public within group a',
      );
      await executeCliWithConfigPath(configPath, 'groups:info', 'a');
      expect(getCleanedMockStdout()).toContain(trim`
        │public │            │Infinity    │
        │private│            │Infinity    │
      `);
    });
  });

  describe('check', () => {
    describe('valid dependencies', () => {
      describe('single group, one application', () => {
        it('should pass', async () => {
          await executeCliWithCopiedConfigFixture(
            'check/single-group-one-app-dependencies-valid',
          )('check', 'a');
          expect(getCleanedMockStdout()).toBe('✔ Check passed!');
        });

        it('should pass, verbose', async () => {
          await executeCliWithCopiedConfigFixture(
            'check/single-group-one-app-dependencies-valid',
          )('check', 'a', '--verbose');
          expect(getCleanedMockStdout()).toBe(trim`
            ℹ
            ┌─────────────┬──────────┬─────────┬────────┬─────┐
            │Application  │Dependency│Installed│Required│Valid│
            ├─────────────┼──────────┼─────────┼────────┼─────┤
            │application_a│dep_a     │^1.0.0   │1.x     │✔    │
            │             │dep_b     │1.2.3    │1.x     │✔    │
            │             │dep_c     │~1.5.0   │1.x     │✔    │
            └─────────────┴──────────┴─────────┴────────┴─────┘
            ✔ Check passed!
          `);
        });
      });

      describe('single group, multiple applications', () => {
        it('should pass', async () => {
          await executeCliWithCopiedConfigFixture(
            'check/single-group-two-apps-dependencies-valid',
          )('check', 'a');
          expect(getCleanedMockStdout()).toBe('✔ Check passed!');
        });

        it('should pass, verbose', async () => {
          await executeCliWithCopiedConfigFixture(
            'check/single-group-two-apps-dependencies-valid',
          )('check', 'a', '--verbose');
          expect(getCleanedMockStdout()).toBe(trim`
            ℹ
            ┌─────────────┬──────────┬─────────┬────────┬─────┐
            │Application  │Dependency│Installed│Required│Valid│
            ├─────────────┼──────────┼─────────┼────────┼─────┤
            │application_a│dep_a     │^1.0.0   │1.x     │✔    │
            │             │dep_b     │1.2.3    │1.x     │✔    │
            │             │dep_c     │~1.5.0   │1.x     │✔    │
            └─────────────┴──────────┴─────────┴────────┴─────┘
            ✔ Check passed!
          `);
        });
      });

      describe('multiple groups, one application per group', () => {
        it('should pass', async () => {
          await executeCliWithCopiedConfigFixture(
            'check/multiple-groups-one-app-per-group-dependencies-valid',
          )('check', 'a', 'b');
          expect(getCleanedMockStdout()).toBe('✔ Check passed!');
        });

        it('should pass, verbose', async () => {
          await executeCliWithCopiedConfigFixture(
            'check/multiple-groups-one-app-per-group-dependencies-valid',
          )('check', 'a', 'b', '--verbose');
          expect(getCleanedMockStdout()).toBe(trim`
            ℹ
            ┌─────────────┬──────────┬─────────┬────────┬─────┐
            │Application  │Dependency│Installed│Required│Valid│
            ├─────────────┼──────────┼─────────┼────────┼─────┤
            │application_a│dep_a     │^1.0.0   │1.x     │✔    │
            │             │dep_b     │1.2.3    │1.x     │✔    │
            │             │dep_c     │~1.5.0   │1.x     │✔    │
            │application_b│dep_a     │^1.5.0   │1.x     │✔    │
            │             │dep_b     │1.6.3    │1.x     │✔    │
            │             │dep_c     │~1.7.0   │1.x     │✔    │
            └─────────────┴──────────┴─────────┴────────┴─────┘
            ┌─────────────┬──────────┬─────────┬────────┬─────┐
            │Application  │Dependency│Installed│Required│Valid│
            ├─────────────┼──────────┼─────────┼────────┼─────┤
            │application_a│dep_a     │^1.0.0   │1.x     │✔    │
            │             │dep_b     │1.2.3    │1.x     │✔    │
            │             │dep_c     │~1.5.0   │1.x     │✔    │
            │application_b│dep_a     │^1.5.0   │1.x     │✔    │
            │             │dep_b     │1.6.3    │1.x     │✔    │
            │             │dep_c     │~1.7.0   │1.x     │✔    │
            └─────────────┴──────────┴─────────┴────────┴─────┘
            ✔ Check passed!
          `);
        });
      });

      describe('no group arguments', () => {
        it('should pass', async () => {
          await executeCliWithCopiedConfigFixture(
            'check/multiple-groups-one-app-per-group-dependencies-valid',
          )('check');
          expect(getCleanedMockStdout()).toBe('✔ Check passed!');
        });

        it('should pass, verbose', async () => {
          await executeCliWithCopiedConfigFixture(
            'check/multiple-groups-one-app-per-group-dependencies-valid',
          )('check', '--verbose');
          expect(getCleanedMockStdout()).toBe(trim`
          ℹ
          ┌─────────────┬──────────┬─────────┬────────┬─────┐
          │Application  │Dependency│Installed│Required│Valid│
          ├─────────────┼──────────┼─────────┼────────┼─────┤
          │application_a│dep_a     │^1.0.0   │1.x     │✔    │
          │             │dep_b     │1.2.3    │1.x     │✔    │
          │             │dep_c     │~1.5.0   │1.x     │✔    │
          │application_b│dep_a     │^1.5.0   │1.x     │✔    │
          │             │dep_b     │1.6.3    │1.x     │✔    │
          │             │dep_c     │~1.7.0   │1.x     │✔    │
          └─────────────┴──────────┴─────────┴────────┴─────┘
          ┌─────────────┬──────────┬─────────┬────────┬─────┐
          │Application  │Dependency│Installed│Required│Valid│
          ├─────────────┼──────────┼─────────┼────────┼─────┤
          │application_a│dep_a     │^1.0.0   │1.x     │✔    │
          │             │dep_b     │1.2.3    │1.x     │✔    │
          │             │dep_c     │~1.5.0   │1.x     │✔    │
          │application_b│dep_a     │^1.5.0   │1.x     │✔    │
          │             │dep_b     │1.6.3    │1.x     │✔    │
          │             │dep_c     │~1.7.0   │1.x     │✔    │
          └─────────────┴──────────┴─────────┴────────┴─────┘
          ✔ Check passed!
        `);
        });
      });
    });

    describe('invalid dependencies', () => {
      describe('single group, one application', () => {
        it('should fail', async () => {
          try {
            await executeCliWithCopiedConfigFixture(
              'check/single-group-one-app-dependencies-invalid',
            )('check', 'a');
            expect(true).toBe(false);
          } catch (e) {
            expect(getCleanedMockStdout()).toBe(
              '✖ Group a did not meet dependency version requirements',
            );
          }
        });

        it('should fail, verbose', async () => {
          try {
            await executeCliWithCopiedConfigFixture(
              'check/single-group-one-app-dependencies-invalid',
            )('check', 'a', '--verbose');
            expect(true).toBe(false);
          } catch (e) {
            expect(getCleanedMockStdout()).toBe(trim`
              ℹ
              ┌─────────────┬──────────┬─────────┬────────┬─────┐
              │Application  │Dependency│Installed│Required│Valid│
              ├─────────────┼──────────┼─────────┼────────┼─────┤
              │application_a│dep_a     │^1.0.0   │3.x     │✖    │
              │             │dep_b     │1.2.3    │3.x     │✖    │
              │             │dep_c     │~1.5.0   │3.x     │✖    │
              └─────────────┴──────────┴─────────┴────────┴─────┘
              ✖ Group a did not meet dependency version requirements
            `);
          }
        });
      });

      describe('single group, multiple applications', () => {
        it('should fail', async () => {
          try {
            await executeCliWithCopiedConfigFixture(
              'check/single-group-two-apps-dependencies-invalid',
            )('check', 'a');
            expect(true).toBe(false);
          } catch (e) {
            expect(getCleanedMockStdout()).toBe(
              '✖ Group a did not meet dependency version requirements',
            );
          }
        });

        it('should fail, verbose', async () => {
          try {
            await executeCliWithCopiedConfigFixture(
              'check/single-group-two-apps-dependencies-invalid',
            )('check', 'a', '--verbose');
            expect(true).toBe(false);
          } catch (e) {
            expect(getCleanedMockStdout()).toBe(trim`
              ℹ
              ┌─────────────┬──────────┬─────────┬────────┬─────┐
              │Application  │Dependency│Installed│Required│Valid│
              ├─────────────┼──────────┼─────────┼────────┼─────┤
              │application_a│dep_a     │^1.0.0   │3.x     │✖    │
              │             │dep_b     │1.2.3    │3.x     │✖    │
              │             │dep_c     │~1.5.0   │3.x     │✖    │
              └─────────────┴──────────┴─────────┴────────┴─────┘
              ✖ Group a did not meet dependency version requirements
            `);
          }
        });
      });

      describe('multiple groups, one application per group', () => {
        it('should fail', async () => {
          try {
            await executeCliWithCopiedConfigFixture(
              'check/multiple-groups-one-app-per-group-dependencies-invalid',
            )('check', 'a', 'b');
            expect(true).toBe(false);
          } catch (e) {
            expect(getCleanedMockStdout()).toBe(
              '✖ Groups a, b did not meet dependency version requirements',
            );
          }
        });

        it('should fail, verbose', async () => {
          try {
            await executeCliWithCopiedConfigFixture(
              'check/multiple-groups-one-app-per-group-dependencies-invalid',
            )('check', 'a', 'b', '--verbose');
            expect(true).toBe(false);
          } catch (e) {
            expect(getCleanedMockStdout()).toBe(trim`
              ℹ
              ┌─────────────┬──────────┬─────────┬────────┬─────┐
              │Application  │Dependency│Installed│Required│Valid│
              ├─────────────┼──────────┼─────────┼────────┼─────┤
              │application_a│dep_a     │^1.0.0   │3.x     │✖    │
              │             │dep_b     │1.2.3    │3.x     │✖    │
              │             │dep_c     │~1.5.0   │3.x     │✖    │
              │application_b│dep_a     │^1.5.0   │3.x     │✖    │
              │             │dep_b     │1.6.3    │3.x     │✖    │
              │             │dep_c     │~1.7.0   │3.x     │✖    │
              └─────────────┴──────────┴─────────┴────────┴─────┘
              ┌─────────────┬──────────┬─────────┬────────┬─────┐
              │Application  │Dependency│Installed│Required│Valid│
              ├─────────────┼──────────┼─────────┼────────┼─────┤
              │application_a│dep_a     │^1.0.0   │3.x     │✖    │
              │             │dep_b     │1.2.3    │3.x     │✖    │
              │             │dep_c     │~1.5.0   │3.x     │✖    │
              │application_b│dep_a     │^1.5.0   │3.x     │✖    │
              │             │dep_b     │1.6.3    │3.x     │✖    │
              │             │dep_c     │~1.7.0   │3.x     │✖    │
              └─────────────┴──────────┴─────────┴────────┴─────┘
              ✖ Groups a, b did not meet dependency version requirements
            `);
          }
        });
      });

      describe('no arguments', () => {
        it('should fail', async () => {
          try {
            await executeCliWithCopiedConfigFixture(
              'check/multiple-groups-one-app-per-group-dependencies-invalid',
            )('check');
            expect(true).toBe(false);
          } catch (e) {
            expect(getCleanedMockStdout()).toBe(
              '✖ Groups a, b did not meet dependency version requirements',
            );
          }
        });

        it('should fail, verbose', async () => {
          try {
            await executeCliWithCopiedConfigFixture(
              'check/multiple-groups-one-app-per-group-dependencies-invalid',
            )('check', '--verbose');
            expect(true).toBe(false);
          } catch (e) {
            expect(getCleanedMockStdout()).toBe(trim`
              ℹ
              ┌─────────────┬──────────┬─────────┬────────┬─────┐
              │Application  │Dependency│Installed│Required│Valid│
              ├─────────────┼──────────┼─────────┼────────┼─────┤
              │application_a│dep_a     │^1.0.0   │3.x     │✖    │
              │             │dep_b     │1.2.3    │3.x     │✖    │
              │             │dep_c     │~1.5.0   │3.x     │✖    │
              │application_b│dep_a     │^1.5.0   │3.x     │✖    │
              │             │dep_b     │1.6.3    │3.x     │✖    │
              │             │dep_c     │~1.7.0   │3.x     │✖    │
              └─────────────┴──────────┴─────────┴────────┴─────┘
              ┌─────────────┬──────────┬─────────┬────────┬─────┐
              │Application  │Dependency│Installed│Required│Valid│
              ├─────────────┼──────────┼─────────┼────────┼─────┤
              │application_a│dep_a     │^1.0.0   │3.x     │✖    │
              │             │dep_b     │1.2.3    │3.x     │✖    │
              │             │dep_c     │~1.5.0   │3.x     │✖    │
              │application_b│dep_a     │^1.5.0   │3.x     │✖    │
              │             │dep_b     │1.6.3    │3.x     │✖    │
              │             │dep_c     │~1.7.0   │3.x     │✖    │
              └─────────────┴──────────┴─────────┴────────┴─────┘
              ✖ Groups a, b did not meet dependency version requirements
            `);
          }
        });
      });
    });

    it.todo(
      'should pass and warn if some dependency versions in a group are invalid but inside the grace period',
    );

    it.todo(
      'should fail if some dependency versions in a group are invalid and outside the grace period',
    );
  });
});
